We can create a project using cargo new.
We can build a project using cargo build.
We can build and run a project in one step using cargo run.
We can build a project without producing a binary to check for errors using cargo check.
Instead of saving the result of the build in the same directory as our code, Cargo stores it in the target/debug directory.

When you run `cargo build --release`, Rust compiles your code with optimizations to make it run faster. However, this takes more time to compile compared to the default `cargo build`, which is used for development and compiles quickly but without optimizations.  

In short:  
- **`cargo build`** → Fast compilation, slower execution (for development).  
- **`cargo build --release`** → Slow compilation, faster execution (for final release).  

Key Concepts Used:
Constants (const) – Always immutable and require type annotations.
Mutability (mut) – Allows modifying a variable.
Shadowing – Reusing a variable name but changing its type or value.
Tuples – Multiple values in one variable, accessed by destructuring.
Arrays & Loops – Modifying arrays using a loop.

let guess: u32 = "42".parse().expect("Not a number!");
If we don’t add the : u32 type annotation shown in the preceding code, Rust will display the following error, which means the compiler needs more information from us to know which type we want to use:

Scalar Types
A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Let’s jump into how they work in Rust.

Function 

Statements are instructions that perform some action and do not return a value.
Expressions evaluate to a resultant value.

Types of Functions Demonstrated:
Basic function (greet()) – No parameters, no return.
Function with parameters (add(a, b)) – Takes input, prints result.
Function with a return value (multiply(a, b)) – Returns a computed value.
Function with an explicit return statement (divide(a, b)) – Uses return keyword.
Function returning multiple values (swap(a, b)) – Uses tuples.
Function with mutable reference (increase_by_ten(&mut num)) – Modifies an argument.
Generic function (generic_max<T>(a, b)) – Works with multiple data types.
Function taking a closure (apply(f, value)) – Accepts another function as input.
Higher-order function (make_multiplier(multiplier)) – Returns a function.
Recursive function (factorial(n)) – Calls itself to compute results.
