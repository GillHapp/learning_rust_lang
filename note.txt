We can create a project using cargo new.
We can build a project using cargo build.
We can build and run a project in one step using cargo run.
We can build a project without producing a binary to check for errors using cargo check.
Instead of saving the result of the build in the same directory as our code, Cargo stores it in the target/debug directory.

When you run `cargo build --release`, Rust compiles your code with optimizations to make it run faster. However, this takes more time to compile compared to the default `cargo build`, which is used for development and compiles quickly but without optimizations.  

In short:  
- **`cargo build`** ‚Üí Fast compilation, slower execution (for development).  
- **`cargo build --release`** ‚Üí Slow compilation, faster execution (for final release).  

Key Concepts Used:
Constants (const) ‚Äì Always immutable and require type annotations.
Mutability (mut) ‚Äì Allows modifying a variable.
Shadowing ‚Äì Reusing a variable name but changing its type or value.
Tuples ‚Äì Multiple values in one variable, accessed by destructuring.
Arrays & Loops ‚Äì Modifying arrays using a loop.

let guess: u32 = "42".parse().expect("Not a number!");
If we don‚Äôt add the : u32 type annotation shown in the preceding code, Rust will display the following error, which means the compiler needs more information from us to know which type we want to use:

Scalar Types
A scalar type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages. Let‚Äôs jump into how they work in Rust.

Function 

Statements are instructions that perform some action and do not return a value.
Expressions evaluate to a resultant value.

Types of Functions Demonstrated:
Basic function (greet()) ‚Äì No parameters, no return.
Function with parameters (add(a, b)) ‚Äì Takes input, prints result.
Function with a return value (multiply(a, b)) ‚Äì Returns a computed value.
Function with an explicit return statement (divide(a, b)) ‚Äì Uses return keyword.
Function returning multiple values (swap(a, b)) ‚Äì Uses tuples.
Function with mutable reference (increase_by_ten(&mut num)) ‚Äì Modifies an argument.
Generic function (generic_max<T>(a, b)) ‚Äì Works with multiple data types.
Function taking a closure (apply(f, value)) ‚Äì Accepts another function as input.
Higher-order function (make_multiplier(multiplier)) ‚Äì Returns a function.
Recursive function (factorial(n)) ‚Äì Calls itself to compute results.


üéØ Summary of Rust Control Flow
Control Flow	Usage
if, else if, else	Conditional execution
if let	Match a single pattern concisely
while	Loop while a condition is true
while let	Loop while a pattern matches
for	Iterate over ranges, arrays, and iterators
loop	Infinite loop, exit with break
match	Pattern matching (powerful alternative to if-else)
break	Exit a loop
continue	Skip an iteration
Labeled loops ('label:)	Exit specific loops in nested loops


 Rules of Mutable Borrowing
‚úî Only one mutable reference at a time (prevents race conditions).
‚úî No immutable (&) and mutable (&mut) references at the same time.

‚ùå This will cause an error:

rust
Copy
Edit
let mut s = String::from("hello");
let r1 = &mut s;
let r2 = &mut s; // ‚ùå ERROR: Second mutable borrow not allowed

let mut s = String::from("hello");

{
    let r1 = &mut s; // ‚úÖ Borrow only within this block
}

let r2 = &mut s; // ‚úÖ Allowed because r1 is no longer used

Summary of Ownership in Rust
Concept	Explanation
Ownership	Each value has one owner. When the owner goes out of scope, memory is freed.
Move	Assigning a variable to another moves ownership (String).
Clone	Creates a new copy instead of moving ownership.
Borrowing (&)	Allows reading a value without taking ownership.
Mutable Borrowing (&mut)	Allows modifying a value but only one mutable reference at a time.
Slices (&[T])	References part of a collection without ownership transfer.